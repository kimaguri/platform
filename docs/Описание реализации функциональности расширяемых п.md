<img src="https://r2cdn.perplexity.ai/pplx-full-logo-primary-dark%402x.png" class="logo" width="120"/>

# Описание реализации функциональности расширяемых полей на бэкенде (функциональный подход)

**Основной вывод:**
Создать единый универсальный RPC-эндпоинт в сервисе `content-management`, который при запросе любой сущности извлекает и базовые поля, и динамические поля из JSONB-столбца `custom_fields`, применяет сортировку/фильтрацию по ним и отдаёт фронтенду единый объект. Метаданные расширяемых полей хранятся централизованно в админской БД, а значения — прямо в `custom_fields` таблицы сущности. При росте числа полей (> 20) «холодные» поля обслуживаются опциональной таблицей `extension_table_values`.

## 1. Хранение метаданных и значений

1. **Таблица `extension_table_definitions`** (админская БД):
    - Поля: `tenant_id`, `entity_table`, `field_name`, `field_type`, `is_required`, `display_name` и т. д.
2. **JSONB-столбец `custom_fields`** в каждой сущности:

```sql
ALTER TABLE users ADD COLUMN custom_fields JSONB NOT NULL DEFAULT '{}'::JSONB;
```

3. **(Опционально) Таблица `extension_table_values`**:
    - Используется для «холодных» полей при > 20 динамических полях или сложных кейсах.

## 2. Универсальный RPC-эндпоинт

В `src/services/content-management/api.ts` (функционально, без классов):

```typescript
import { api, getAuthData } from "@encore/backend";
import { queryResource } from "@encore/resource-resolver";
import { db } from "./db-client"; // Knex/Drizzle/etc.

export const getEntityWithExtensions = api(
  { auth: true, method: "GET", path: "/content/:entity/:id" },
  async ({ entity, id }) => {
    const { tenantId } = getAuthData();

    // 1. Базовый запрос к таблице сущности
    const base = await db(entity)
      .select("*")
      .where({ tenant_id: tenantId, id });

    if (base.length === 0) {
      throw new Error("NotFound");
    }

    // 2. Подгрузка метаданных расширений (кешировать на уровне сервиса)
    const definitions = await queryResource(
      tenantId,
      "extension_table_definitions",
      { filter: { entity_table: entity, is_active: true } }
    );

    // 3. Извлечение значений из JSONB
    const raw = base[0];
    const extensions: Record<string, any> = definitions.length
      ? raw.custom_fields || {}
      : {};

    // 4. Сборка ответа
    return {
      data: { ...raw, extensions },
      message: "Content with extensions",
    };
  }
);
```


## 3. Сортировка и фильтрация по `custom_fields`

### 3.1. Индексы в PostgreSQL

```sql
-- Общий GIN-индекс для JSON-поиска
CREATE INDEX ON users USING GIN (custom_fields);

-- Функциональные B-Tree-индексы для горячих полей
CREATE INDEX ON users ((custom_fields->>'favorite_color'));
```


### 3.2. Парсинг параметров Refine на бэкенде

```typescript
function applyCustomFiltersAndSort(qb, filters, sorters) {
  filters.forEach(({ field, operator, value }) => {
    if (field.startsWith("extensions.")) {
      const key = field.split(".")[1];
      const expr = `custom_fields->>'${key}'`;
      qb.whereRaw(`${expr} ${operatorMap[operator]} ?`, [value]);
    } else {
      qb.where(field, operatorMap[operator], value);
    }
  });
  sorters.forEach(({ field, order }) => {
    if (field.startsWith("extensions.")) {
      const key = field.split(".")[1];
      qb.orderByRaw(`custom_fields->>'${key}' ${order}`);
    } else {
      qb.orderBy(field, order);
    }
  });
}
```

В самом эндпоинте:

```typescript
const { filters, sorters, page, pageSize } = parseRefineParams(request);
const qb = db(entity).where({ tenant_id: tenantId });
applyCustomFiltersAndSort(qb, filters, sorters);
const data = await qb.limit(pageSize).offset((page - 1) * pageSize);
```


## 4. Опциональная таблица `extension_table_values`

При превышении 20 полей или для сложных отчётов:

1. **JOIN** на `extension_table_values`:

```sql
SELECT e.*, ext.field_data->>'someField' AS someField
FROM users e
LEFT JOIN extension_table_values ext
  ON ext.entity_table = 'users'
  AND ext.entity_id = e.id
WHERE ext.field_data->>'someField' = 'value';
```

2. Логика выбора источника (`custom_fields` vs `extension_table_values`) реализуется в том же `applyCustomFiltersAndSort`, добавляя JOIN для «холодных» полей.

## 5. Интеграция в API-Gateway

```typescript
// gateway/endpoints/content-endpoints.ts
import { api } from "@encore/backend";
import { contentClient } from "../service-clients";

export const getContent = api(
  { auth: true, method: "GET", path: "/api/v1/content/:entity/:id", expose: true },
  async ({ entity, id }) => {
    const result = await contentClient.getEntityWithExtensions({ entity, id });
    return { data: result.data, message: result.message };
  }
);
```

Фронтенд всегда делает единый вызов:

```
GET /api/v1/content/users/123
```

и получает:

```json
{
  "data": {
    "id": "123",
    "name": "Иван",
    // …другие поля…
    "extensions": {
      "favorite_color": "blue",
      "signup_source": "partner"
    }
  },
  "message": "Content with extensions"
}
```

**Итог:**

- Метаданные хранить в `extension_table_definitions`.
- Значения в `custom_fields: JSONB`.
- Единственный универсальный endpoint объединяет данные и расширения без классов.
- Гибкая фильтрация/сортировка по динамическим полям через JSONB и индексы.
- При росте числа полей — off-load «холодных» полей в `extension_table_values`.

