<img src="https://r2cdn.perplexity.ai/pplx-full-logo-primary-dark%402x.png" class="logo" width="120"/>

# Универсальная архитектура для мульти-тенантного приложения на Encore TS + Supabase + refine.dev

**Краткий вывод:**
Каждому тенанту соответствует отдельный проект Supabase с собственными URL и ключами. Хранить эти параметры нужно централизованно в бекенде (Encore TS)—в безопасном хранилище секретов (например, HashiCorp Vault, AWS Secrets Manager или переменные окружения CI/CD). Фронтенд (refine.dev) получает динамически URL и анони ключ с бекенда через защищённый эндпоинт и не хранит их на стороне клиента.

## 1. Обзор компонентов и задач

- **Supabase (каждому тенанту свой проект)**
    - Auth (GoTrue)
    - PostgREST для CRUD
    - Storage \& Realtime
- **API Gateway / микросервисы на Encore TS**
    - Универсальный data provider по имени сущности
    - Разделение конфигураций Supabase по тенантам
- **Frontend (refine.dev)**
    - Data provider для CRUD
    - Получение конфигурации Supabase на старте
    - Не хранит суперключи


## 2. Где хранить параметры Supabase

### 2.1. Бекенд (Encore TS) как источник правды

1. В Encore TS-конфиге (encore.config.ts) не хранить сами значения, а ссылаться на переменные окружения:

```ts
// encore.config.ts
export default {
  services: {
    gateway: { path: "./services/gateway" },
  },
  env: {
    TENANT_CONFIG: { required: true }, // JSON со всеми tenant’ами
  }
} as Config;
```

2. Переменная `TENANT_CONFIG` содержит маппинг каждого tenantId → { url, anonKey, serviceKey } в виде JSON-строки.
3. На проде и в CI/CD систему (GitHub Actions, GitLab CI, Vercel, Netlify) загружают реальный JSON в безопасный раздел секретов.

### 2.2. Пример структуры JSON-конфига

```jsonc
// значение переменной TENANT_CONFIG
{
  "tenant1": {
    "SUPABASE_URL": "https://abc123.supabase.co",
    "SUPABASE_ANON_KEY": "anon-key-…",
    "SUPABASE_SERVICE_KEY": "service-role-key-…"
  },
  "tenant2": {
    "SUPABASE_URL": "https://xyz789.supabase.co",
    "SUPABASE_ANON_KEY": "anon-key-…",
    "SUPABASE_SERVICE_KEY": "service-role-key-…"
  }
}
```


## 3. API Gateway: динамическое определение клиента Supabase

1. **Инициализация клиента**
По заголовку запроса (например, `X-Tenant-ID`) или JWT-полу содержит tenantId.

```ts
// services/gateway/src/utils/supabase.ts
import { createClient } from "@supabase/supabase-js";

const config = JSON.parse(process.env.TENANT_CONFIG!);

export function getSupabaseClient(tenantId: string) {
  const { SUPABASE_URL, SUPABASE_ANON_KEY, SUPABASE_SERVICE_KEY } = config[tenantId];
  return createClient(SUPABASE_URL, SUPABASE_SERVICE_KEY!);
}
```

2. **Middleware для идентификации tenant**

```ts
// tenantMiddleware.ts
import { Middleware } from "encore.dev/api";

export const tenantMiddleware: Middleware = async (req, res, next) => {
  const tenantId = req.headers["x-tenant-id"] as string;
  if (!tenantId) throw new Error("Tenant ID is required");
  req.context.tenantId = tenantId;
  next();
};
```

3. **Эндпоинт для получения конфигурации фронтенду**
Позволяет фронтенду динамически узнать URL и анони ключ (без сервисного ключа):

```ts
export const getConfig = api(
  { method: "GET", path: "/config", middlewares: [tenantMiddleware], expose: true },
  ({}, req) => {
    const cfg = JSON.parse(process.env.TENANT_CONFIG!)[req.context.tenantId];
    return { url: cfg.SUPABASE_URL, anonKey: cfg.SUPABASE_ANON_KEY };
  }
);
```


## 4. Data Provider в refine.dev: универсальный подход

1. При загрузке приложения (или после входа) делать запрос к `/config` и инициализировать Supabase-клиент:

```ts
// src/refineProvider.ts
import { SupabaseClient, createClient } from "@supabase/supabase-js";

let supabase: SupabaseClient;

export const initDataProvider = async () => {
  const { url, anonKey } = await fetch("/api/config").then(r => r.json());
  supabase = createClient(url, anonKey);
};

export const dataProvider = {
  getList: async (resource, params) => {
    return supabase.from(resource).select("*");
  },
  getOne: async (resource, { id }) => {
    return supabase.from(resource).select("*").eq("id", id).single();
  },
  create: async (resource, { data }) => {
    return supabase.from(resource).insert(data).single();
  },
  update: async (resource, { id, data }) => {
    return supabase.from(resource).update(data).eq("id", id).single();
  },
  delete: async (resource, { id }) => {
    return supabase.from(resource).delete().eq("id", id).single();
  },
};
```

2. В `refine` передать `dataProvider` после `initDataProvider()`.

## 5. Универсальность при переходе от Supabase

- Вся логика работы с конкретным API завёрнута в data provider.
- Дернуть паттерн «adapter» — реализовать интерфейс data provider для любого бекенда.
- При смене Supabase на другую БД/REST API достаточно заменить только реализацию `dataProvider`, не меняя UI и логику вызовов.


## 6. Итоги и рекомендации

1. **Безопасное хранение**: все ключи лежат в бекенде (секреты CI/CD), на фронтенде только anonKey из защищённого эндпоинта.
2. **Динамическая настройка**: tenantId в заголовке → конкретный Supabase-клиент.
3. **Универсальный data provider**: по имени сущности (таблицы) работает как с Supabase, так и с любым другим бекендом при смене адаптера.
4. **Отказ от RLS**: пока не требуется, позже можно добавить Row Level Security на уровне Supabase с тем же tenantId.
5. **refine.dev**: использует полученный на старте `dataProvider` без явного описания endpoint’ов для каждой сущности.

Данный подход обеспечивает **безопасность**, **гибкость** и **прозрачность** для фронтенд- и бекенд-разработки в мульти-тенантной среде.

